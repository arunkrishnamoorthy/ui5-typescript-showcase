"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModuleTransformVisitor = void 0;
var _core = require("@babel/core");
var th = _interopRequireWildcard(require("../utils/templates"));
var ast = _interopRequireWildcard(require("../utils/ast"));
var _jsdoc = require("../classes/helpers/jsdoc");
const _excluded = ["opts"];
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
const tempModuleName = name => `__${name}`;
const cleanImportSource = src => src.replace(/(\/)|(-)|(@)/g, "_").replace(/\./g, "");
const hasGlobalExportFlag = node => (0, _jsdoc.hasJsdocGlobalExportFlag)(node);
const addModuleImport = (imports, name) => {
  const existingImport = imports.find(imp => imp.src === name);
  if (!existingImport) {
    imports.unshift({
      src: name,
      name: name,
      tmpName: name
    });
  }
};
const ModuleTransformVisitor = exports.ModuleTransformVisitor = {
  /*!
   * Removes the ES6 import and adds the details to the import array in our state.
   */
  ImportDeclaration(path, _ref) {
    let {
        opts = {}
      } = _ref,
      state = _objectWithoutProperties(_ref, _excluded);
    const {
      node
    } = path;
    if (node.importKind === "type") return; // flow-type

    const {
      specifiers,
      source
    } = node;
    const src = source.value.replace(/\\/g, "/");

    // When 'libs' are used, only 'libs' will be converted to UI5 imports.
    const {
      libs = [".*"]
    } = opts;
    const isLibToConvert = new RegExp(`(${libs.join("|")})`).test(src);
    if (!isLibToConvert) {
      this.ignoredImports.push(node);
      path.remove();
      return;
    }

    //const testSrc = (opts.libs || ["^sap/"]).concat(opts.files || []);
    // const isUi5SrcRE = testSrc.length && new RegExp(`(${testSrc.join("|")})`);
    // const isUi5Src = isUi5SrcRE.test(src);

    // Importing using an interop is the default behaviour but can be opt-out using regex.
    const shouldInterop = !this.noImportInteropPrefixesRegexp.test(src);
    const name = cleanImportSource(src); // default to the src for import without named var

    const {
      modulesMap = {}
    } = opts;
    const mappedSrc = (typeof modulesMap === "function" ? modulesMap(src, {
      node,
      opts,
      cwd: state.cwd,
      filename: state.filename,
      file: {
        opts: state.file.opts
      }
    }) : modulesMap[src]) || src;

    // Note that existingImport may get mutated if there are multiple import lines from the same module.
    const existingImport = this.imports.find(imp => imp.src === mappedSrc);
    const imp = existingImport || {
      src: mappedSrc,
      // url
      name,
      // isLib, // for future use separating UI5 imports from npm/webpack imports
      // isUi5Src, // not used yet
      tmpName: shouldInterop ? tempModuleName(name) : name,
      deconstructors: [],
      default: false,
      interop: false,
      path: path,
      locked: false
    };
    const deconstructors = [];
    for (const specifier of specifiers) {
      if (_core.types.isImportDefaultSpecifier(specifier)) {
        // e.g. import X from 'X'
        imp.default = true;
        imp.interop = shouldInterop;

        // Shorten the imported-as name since it should be unique for default imports.
        // The default import should always come first,
        // so this new name will be used for destructuring the other too.
        if (!imp.locked) {
          imp.name = specifier.local.name;
          imp.tmpName = shouldInterop ? tempModuleName(imp.name) : imp.name;
          imp.locked = true;
        }
        if (shouldInterop) {
          deconstructors.push(th.buildDefaultImportDeconstructor({
            MODULE: _core.types.identifier(imp.tmpName),
            LOCAL: specifier.local
          }));
        }
      } else if (_core.types.isImportNamespaceSpecifier(specifier)) {
        if (specifiers.length === 1 && !imp.locked) {
          // e.g. import * as X from 'X'
          // If the namespace specifier is the only import, we can avoid the temp name and the destructor
          imp.name = specifier.local.name;
          imp.tmpName = specifier.local.name;
          imp.locked = true; // Don't let another import line for the same module change the name.
        } else {
          // e.g. import X, * as X2 from 'X'
          // Else it's probably combined with a default export. keep the tmpName and destructure it
          deconstructors.push(th.buildConstDeclaration({
            NAME: specifier.local,
            VALUE: _core.types.identifier(imp.tmpName)
          }));
        }
      } else if (_core.types.isImportSpecifier(specifier)) {
        // e.g. import { A } from 'X'
        deconstructors.push(th.buildNamedImportDestructor({
          MODULE: _core.types.identifier(imp.tmpName),
          LOCAL: specifier.local,
          IMPORTED: _core.types.stringLiteral(specifier.imported.name)
        }));
      } else {
        throw path.buildCodeFrameError(`Unknown ImportDeclaration specifier type ${specifier.type}`);
      }
    }

    // this is the very first import in noWrapBeforeImport mode and there are sibling nodes before this import
    if (opts.noWrapBeforeImport && !this.firstImportMarked && path.inList && path.key > 0) {
      // mark the direct predecessor as the last one to exclude from wrapping
      path.getSibling(path.key - 1).node.lastBeforeWrapping = true;
      this.firstImportMarked = true;
    }
    path.replaceWithMultiple(deconstructors);
    if (deconstructors.length) {
      // Keep the same variable name if the same module is imported on another line.
      imp.locked = true;
    }
    imp.deconstructors = imp.deconstructors.concat(deconstructors);
    if (!existingImport) {
      this.imports.push(imp);
    }
  },
  /**
   * Push all exports to an array.
   * The reason we don't export in place is to handle the situation
   * where a let or var can be defined, and the latest one should be exported.
   */
  ExportNamedDeclaration(path) {
    const {
      node
    } = path;
    const {
      specifiers,
      declaration,
      source
    } = node;
    let fromSource = "";
    if (source) {
      // e.g. export { one, two } from 'x'
      const src = source.value;
      const name = cleanImportSource(src);
      const tmpName = tempModuleName(name);
      this.imports.push({
        src,
        name,
        tmpName
      });
      fromSource = tmpName + ".";
    }
    if (specifiers && specifiers.length) {
      // e.g. export { one, two }
      for (const specifier of path.node.specifiers) {
        this.namedExports.push({
          key: specifier.exported,
          value: _core.types.identifier(`${fromSource}${specifier.local.name}`)
        });
      }
      path.remove();
    } else if (declaration) {
      // e.g. export const c = 1 | export function f() {}
      if (["TypeAlias", "InterfaceDeclaration", "TSInterfaceDeclaration", "TSTypeAliasDeclaration"].includes(declaration.type)) return; // TS or Flow-types
      const name = ast.getIdName(declaration);
      if (name) {
        // e.g. export function f() {}
        const id = _core.types.identifier(declaration.id.name);
        this.namedExports.push({
          key: id,
          value: id,
          declaration
        });
      } else if (declaration.declarations) {
        // e.g. export const c = 1
        for (const subDeclaration of declaration.declarations) {
          const id = _core.types.identifier(subDeclaration.id.name);
          this.namedExports.push({
            value: id,
            key: id,
            declaration: subDeclaration
          });
        }
      } else {
        throw path.buildCodeFrameError("Unknown ExportNamedDeclaration shape.");
      }
      path.replaceWith(declaration);
    } else {
      path.remove();
      return;
    }
  },
  ExportDefaultDeclaration(path) {
    const {
      node
    } = path;
    let {
      declaration
    } = node;
    const declarationName = ast.getIdName(declaration);
    if (hasGlobalExportFlag(node)) {
      // check for jsdoc @export
      this.exportGlobal = true;
    }
    if (declarationName) {
      // ClassDeclaration or FunctionDeclaration with name.
      // Leave the declaration in-line and preserve the identifier for the return statement.
      path.replaceWith(declaration);
      this.defaultExport = _core.types.identifier(declarationName);
    } else if (_core.types.isIdentifier(declaration)) {
      this.defaultExport = declaration;
      path.remove();
    } else {
      // anonymous ObjectExpression or anonymous FunctionDeclaration
      if (_core.types.isFunctionDeclaration(declaration)) {
        const {
          params,
          body,
          generator,
          async: isAsync
        } = declaration;
        declaration = _core.types.functionExpression(null, params, body, generator, isAsync);
      }
      const exportDeclaration = th.buildTempExport({
        VALUE: declaration
      });
      path.replaceWith(exportDeclaration);
      this.defaultExport = th.exportsIdentifier;
    }
  },
  ExportAllDeclaration(path) {
    const src = path.node.source.value;
    const name = src.replace(/\//g, "_").replace(/\./g, "");
    const tmpName = tempModuleName(name);
    this.imports.push({
      src,
      name,
      tmpName
    });
    this.exportAllHelper = true;
    this.namedExports.push({
      all: true,
      value: _core.types.identifier(tmpName)
    });
    path.remove();
  },
  /*!
   * Visits function calls to handle for dynamic imports.
   */
  CallExpression(path) {
    const {
      node
    } = path;
    const {
      callee
    } = node;
    if (ast.isImport(callee)) {
      this.injectDynamicImportHelper = true;
      path.replaceWith(_objectSpread(_objectSpread({}, node), {}, {
        callee: _core.types.identifier("__ui5_require_async")
      }));
    }
  },
  MemberExpression(path) {
    var _node$object;
    const {
      node
    } = path;
    if ((node === null || node === void 0 || (_node$object = node.object) === null || _node$object === void 0 ? void 0 : _node$object.type) === "MetaProperty") {
      var _node$property, _node$property2;
      // replace all "import.meta.url" with "module.url"
      if ((node === null || node === void 0 || (_node$property = node.property) === null || _node$property === void 0 ? void 0 : _node$property.name) === "url") {
        path.replaceWith(_objectSpread(_objectSpread({}, node), (0, _core.template)`module.url`()));
        addModuleImport(this.imports, "module");
      }
      // replace all "import.meta.resolve(...)" with "require.toUrl(...)"
      else if ((node === null || node === void 0 || (_node$property2 = node.property) === null || _node$property2 === void 0 ? void 0 : _node$property2.name) === "resolve") {
        path.replaceWith(_objectSpread(_objectSpread({}, node), (0, _core.template)`require.toUrl`()));
        addModuleImport(this.imports, "require");
      }
    }
  }
};